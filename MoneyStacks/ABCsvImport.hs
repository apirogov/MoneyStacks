{-# LANGUAGE OverloadedStrings #-}
{-|
Module      : MoneyStacks.ABCsvImport
Description : Sync transactions with a CSV file generated by AqBanking-CLI
Copyright   : (c) Anton Pirogov, 2014
License     : MIT
Stability   : experimental
Portability : POSIX
-}
module ABCsvImport
where

import qualified Data.Vector as V
import qualified Data.ByteString.Lazy as B
import qualified Data.Map as M
import Data.Char (ord, isDigit)
import Data.Csv

import MoneyStacks.Core
import MoneyStacks.Parser (parseArgDate)
import Data.Time.Calendar (fromGregorian)
import Data.Maybe (fromJust, fromMaybe)

readCSVFile = B.readFile

-- | Take ByteString with CSV data from AqBanking-CLI CSV output, return error or parsed transfers
parseCsv :: B.ByteString -> Either String [Transfer]
parseCsv str = case parsed of
  Left err  -> Left err
  Right dat -> Right $ map (toTransfer . M.fromList) $ filterCsv $ V.toList dat
  where parsed = decodeWith defaultDecodeOptions{decDelimiter=fromIntegral (ord ';')}
                            NoHeader str :: Either String (V.Vector [String])
        -- Zip header of column with each cell, fold each row to one record map
        filterCsv (header:recs) = map M.toList $ map (foldl mappify $ M.fromList []) $ map (zip header) recs

        mappify rec (key,val) =  if key' `elem` ignoredKeys then rec else M.insertWith' mergeKeys key' val rec
          where key' = filter (not.isDigit) key -- multiple fields like purpose purpose1 purpose2 ... -> purpose
                mergeKeys new old = if null new then old else old ++ " " ++ new
                ignoredKeys = ["category", "transactionId", "localBankCode", "value_currency", "valutadate"]

        toTransfer m = nullTransfer {tSrc="", tDst="main", tVal=Just val, tDate=date, tText=text}
          where val  = round (read vstr :: Float)
                vstr = fromMaybe "0" $ M.lookup "value_value" m
                date = fromJust $ parseArgDate (fromGregorian 0 0 0) datestr
                datestr = map ('/' `to` '-') $ fromMaybe "0-1-1" $ M.lookup "date" m
                text = (fromMaybe "" $ M.lookup "remoteName" m) -- ++ " " ++ (fromMaybe "" $ M.lookup "purpose" m)
                a `to` b = \x -> if x==a then b else x


-- TODO: filter out movement within accounts (for us - all accounts = one thing) - same value with - other sign on same date?
-- sort transfer list, allow merging into moneystacks conf (no dups)
-- allow filtering by remote Name to assign to stacks (look in description from/to who it was, decide source stack)
